<html>

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
  <link href="/static/bootstrap.min.css" rel="stylesheet">
  <style>
    .fixed-top {
      position: fixed;
      top: 0;
      right: 0;
      left: 0;
      z-index: 1030;
      /* Bootstrap's z-index for fixed-top */
      padding: 1rem;
      margin: 10px;
    }

    body {
      padding-top: 60px;
      /* Adjust based on the height of your alert */
    }
  </style>
</head>

<div id="alerts" class="alert alert-warning alert-dismissible fade show" role="alert" style="display: none;">
  <strong>Saved!</strong> Your text was saved.
  <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
</div>


<h2 class="mb-4">Secret Scratchpad</h2>
<textarea id="editor" class="form-control mb-4" rows="10" placeholder="Enter your text here..."></textarea>
<input type="text" id="keyInput" class="form-control mb-4" placeholder="Enter AES-GCM Key">
<button id="submitBtn" class="btn btn-primary">Submit</button>

<!-- Note the usage of `type=module` here as this is an ES6 module -->
<script type="module">
  // Use ES module import syntax to import functionality from the module
  // that we have compiled.
  //
  // Note that the `default` import is an initialization function which
  // will "boot" the module and make it ready to use. Currently browsers
  // don't support natively imported WebAssembly as an ES module, but
  // eventually the manual initialization won't be required!
  import init, { add } from '/static/web.js';

  async function run() {
    // First up we need to actually load the wasm file, so we use the
    // default export to inform it where the wasm file is located on the
    // server, and then we wait on the returned promise to wait for the
    // wasm to be loaded.
    //
    // It may look like this: `await init('./pkg/without_a_bundler_bg.wasm');`,
    // but there is also a handy default inside `init` function, which uses
    // `import.meta` to locate the wasm file relatively to js file.
    //
    // Note that instead of a string you can also pass in any of the
    // following things:
    //
    // * `WebAssembly.Module`
    //
    // * `ArrayBuffer`
    //
    // * `Response`
    //
    // * `Promise` which returns any of the above, e.g. `fetch("./path/to/wasm")`
    //
    // This gives you complete control over how the module is loaded
    // and compiled.
    //
    // Also note that the promise, when resolved, yields the wasm module's
    // exports which is the same as importing the `*_bg` module in other
    // modes
    await init();

    document.querySelector('.btn-close').addEventListener('click', function () {
      var alertElement = document.querySelector('.alert');
      alertElement.style.display = 'none';
    });

    setTimeout(function () {
      var alertElement = document.querySelector('.alert');
      alertElement.style.display = 'none';
    }, 10);

    // And afterwards we can use all the functionality defined in wasm.
    const result = add(1, 2);
    console.log(`1 + 2 = ${result}`);
    if (result !== 3)
      throw new Error("wasm addition doesn't work!");
  }

  run();
</script>
</body>

</html>